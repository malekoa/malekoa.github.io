<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.134.2">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Building an Event Queue Service Using Go &middot; malekoa.com</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://malekoa.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://malekoa.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://malekoa.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://malekoa.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" layout-reverse">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://malekoa.com/"><h1>malekoa.com</h1></a>
      <p class="lead">
       Notes on things I&#39;m working on. 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://malekoa.com/">Home</a> </li>
        <li><a href="/about"> About </a></li><li><a href="https://www.github.com/malekoa/"> GitHub </a></li><li><a href="https://www.linkedin.com/in/malekoa/"> LinkedIn </a></li>
      </ul>
    </nav>

    <p>This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>. This blog was made with <a href="https://gohugo.io/">Hugo</a>.</p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Building an Event Queue Service Using Go</h1>
  <time datetime=2024-06-15T19:26:35-0700 class="post-date">Sat, Jun 15, 2024</time>
  <blockquote>
<p>This post documents the process of developing an event queue service in Go. To see the full code, check out the <a href="https://github.com/malekoa/event-queue-service">Github repository</a></p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<p>When working with microservices, it&rsquo;s important to keep your services decoupled. This makes it easier to change one component without affecting the others. But your services still need to communicate with each other. One way to do this is to have components send messages directly to each other. But this can lead to tight coupling between components, making it harder to change one component without affecting the others.</p>
<p>A better way to have components communicate is to use an event queue. An event queue is a service that brokers messages between components without them having to know anything about each other.</p>
<p>A basic event queue with a producer, queue, and consumer looks like this:</p>
<p><img src="queue_diagram.webp" alt="Event queue service diagram">
<em>Figure 1: Event queue service diagram.</em></p>
<p>I&rsquo;ll be designing and building an event queue service that can be used to send messages between components in a distributed system. Then, I&rsquo;ll show it in action by building a simple producer and consumer that communicate with each other using the event queue.</p>
<h2 id="designing-the-event-queue-service">Designing the Event Queue Service</h2>
<h3 id="queues">Queues</h3>
<p>The event queue service will need to keep track of the messages it receives. I&rsquo;ll use (surprise!) a queue data structure to store these messages.</p>
<p>There are many ways to implement a queue in Go, each with benefits and drawbacks:</p>
<ul>
<li><strong>Using a slice</strong>: A slice is a dynamic array that can grow or shrink, like an ArrayList in Java. It&rsquo;s easy to use and understand, but removing elements from the front of the slice runs in O(n) time.</li>
<li><strong>Using a doubly linked list</strong>: A doubly linked list is a linked list where the nodes have pointers to the next and previous nodes. It&rsquo;s more complex than a slice but it has O(1) time complexity for adding and removing elements from the front and back of the list. However, it&rsquo;s less cache-friendly than a slice because the nodes aren&rsquo;t stored contiguously in memory.</li>
<li><strong>Using a ring buffer</strong>: The best of both worlds, a ring buffer is a fixed-size slice that wraps around when it reaches its capacity. It has O(1) time complexity for both adding and removing elements and, because it&rsquo;s using a slice, is more cache-friendly than a linked list. Another benefit of using a ring buffer is that memory is allocated when the buffer is created, so there&rsquo;s no need to allocate memory for each new element.</li>
</ul>
<p>Ring buffers seem like the best choice for this use case, so I&rsquo;ll be using one to implement the service.</p>
<h3 id="implementing-the-ring-buffer">Implementing the Ring Buffer</h3>
<p>A ring buffer looks like a normal slice, but we keep track of the head and tail end of the buffer so we know where to add and remove elements when enqueuing and dequeuing. When the tail reaches the end of the buffer, it wraps around to the beginning.</p>
<p>An empty ring buffer looks like this:</p>
<p><img src="empty_ring_buffer.webp" alt="Empty ring buffer">
<em>Figure 2: An empty ring buffer.</em></p>
<p>When we enqueue an element, we add it to the tail end of the buffer and move the tail pointer:
<img src="enqueue_element.webp" alt="Enqueueing an element">
<em>Figure 3: Enqueueing an element.</em></p>
<p>We can keep adding elements until the buffer is full (notice how the tail pointer wraps around to the beginning of the buffer):
<img src="full_ring_buffer.webp" alt="Full ring buffer">
<em>Figure 4: A full ring buffer.</em></p>
<p>When we dequeue an element, we remove it from the head end of the buffer and move the head pointer:
<img src="dequeue_element.webp" alt="Dequeueing an element">
<em>Figure 5: Dequeueing an element.</em></p>
<p>A ring buffer should support the following operations:</p>
<ul>
<li><strong>Enqueue</strong>: Add an element to the tail end of the buffer.</li>
<li><strong>Dequeue</strong>: Remove an element from the head end of the buffer.</li>
<li><strong>Size</strong>: Return the number of elements in the buffer.</li>
<li><strong>Capacity</strong>: Return the total capacity of the buffer.</li>
<li><strong>IsEmpty</strong>: Return true if the buffer is empty.</li>
<li><strong>IsFull</strong>: Return true if the buffer is full.</li>
</ul>
<p>Here&rsquo;s a basic ring buffer implementation in Go:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fe8019">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">import</span> <span style="color:#b8bb26">&#34;errors&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">type</span> RingBuffer <span style="color:#fe8019">struct</span> {
</span></span><span style="display:flex;"><span>	buffer []<span style="color:#fe8019">interface</span>{}
</span></span><span style="display:flex;"><span>	size   <span style="color:#fabd2f">int</span>
</span></span><span style="display:flex;"><span>	head   <span style="color:#fabd2f">int</span>
</span></span><span style="display:flex;"><span>	tail   <span style="color:#fabd2f">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> <span style="color:#fabd2f">NewRingBuffer</span>(capacity <span style="color:#fabd2f">int</span>) <span style="color:#fe8019">*</span>RingBuffer {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> <span style="color:#fe8019">&amp;</span>RingBuffer{
</span></span><span style="display:flex;"><span>		buffer: <span style="color:#fabd2f">make</span>([]<span style="color:#fe8019">interface</span>{}, capacity),
</span></span><span style="display:flex;"><span>		size:   <span style="color:#d3869b">0</span>,
</span></span><span style="display:flex;"><span>		head:   <span style="color:#d3869b">0</span>,
</span></span><span style="display:flex;"><span>		tail:   <span style="color:#d3869b">0</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> (rb <span style="color:#fe8019">*</span>RingBuffer) <span style="color:#fabd2f">Enqueue</span>(item <span style="color:#fe8019">interface</span>{}) <span style="color:#fabd2f">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">if</span> rb.size <span style="color:#fe8019">==</span> <span style="color:#fabd2f">len</span>(rb.buffer) {
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">return</span> errors.<span style="color:#fabd2f">New</span>(<span style="color:#b8bb26">&#34;cannot enqueue to a full buffer&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	rb.buffer[rb.tail] = item
</span></span><span style="display:flex;"><span>	rb.tail = (rb.tail <span style="color:#fe8019">+</span> <span style="color:#d3869b">1</span>) <span style="color:#fe8019">%</span> <span style="color:#fabd2f">len</span>(rb.buffer)
</span></span><span style="display:flex;"><span>	rb.size<span style="color:#fe8019">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> <span style="color:#fe8019">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> (rb <span style="color:#fe8019">*</span>RingBuffer) <span style="color:#fabd2f">Dequeue</span>() (<span style="color:#fe8019">interface</span>{}, <span style="color:#fabd2f">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">if</span> rb.size <span style="color:#fe8019">==</span> <span style="color:#d3869b">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">return</span> <span style="color:#fe8019">nil</span>, errors.<span style="color:#fabd2f">New</span>(<span style="color:#b8bb26">&#34;cannot dequeue from an empty buffer&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	item <span style="color:#fe8019">:=</span> rb.buffer[rb.head]
</span></span><span style="display:flex;"><span>	rb.head = (rb.head <span style="color:#fe8019">+</span> <span style="color:#d3869b">1</span>) <span style="color:#fe8019">%</span> <span style="color:#fabd2f">len</span>(rb.buffer)
</span></span><span style="display:flex;"><span>	rb.size<span style="color:#fe8019">--</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> item, <span style="color:#fe8019">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> (rb <span style="color:#fe8019">*</span>RingBuffer) <span style="color:#fabd2f">Size</span>() <span style="color:#fabd2f">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> rb.size
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> (rb <span style="color:#fe8019">*</span>RingBuffer) <span style="color:#fabd2f">Capacity</span>() <span style="color:#fabd2f">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> <span style="color:#fabd2f">len</span>(rb.buffer)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> (rb <span style="color:#fe8019">*</span>RingBuffer) <span style="color:#fabd2f">IsEmpty</span>() <span style="color:#fabd2f">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> rb.size <span style="color:#fe8019">==</span> <span style="color:#d3869b">0</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> (rb <span style="color:#fe8019">*</span>RingBuffer) <span style="color:#fabd2f">IsFull</span>() <span style="color:#fabd2f">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> rb.size <span style="color:#fe8019">==</span> <span style="color:#fabd2f">len</span>(rb.buffer)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This implementation uses a slice to store the elements and keeps track of the head and tail pointers. The <code>Enqueue</code> and <code>Dequeue</code> methods update the pointers accordingly. The <code>Size</code>, <code>Capacity</code>, <code>IsEmpty</code>, and <code>IsFull</code> methods provide information about the buffer.</p>
<h2 id="interacting-with-the-event-queue-service-from-a-client">Interacting With the Event Queue Service from a Client</h2>
<p>Now that we have the RingBuffer implementation, we can use it to build the event queue service. There are two common ways to interact with a service like this:</p>
<ol>
<li><strong>HTTP API</strong>: The service exposes a set of RESTful endpoints that clients can use to interact with the service. For example, a client can send a POST request to the <code>/enqueue</code> endpoint to add a message to the queue.</li>
<li><strong>gRPC</strong>: The service defines a set of protocol buffer message types and service definitions that clients can use to interact with the service. For example, a client can call the <code>Enqueue</code> method on the service to add a message to the queue.</li>
</ol>
<p>The choice between an HTTP API and gRPC depends on the requirements of the system. HTTP APIs, in my opinion, are easier to work with and debug while, from what I understand, gRPC is more efficient and has better support for streaming and bidirectional communication.</p>
<p>I&rsquo;ll be using an HTTP API for this service, as it&rsquo;s simpler to set up and use. The messages will be sent as stringified JSON payloads. The service will look something like this:</p>
<p><img src="event_queue_service.webp" alt="Event queue service with HTTP API">
<em>Figure 6: Event queue service with HTTP API.</em></p>
<h3 id="implementing-the-http-api">Implementing the HTTP API</h3>
<p>To pass messages to the event queue service, clients will send HTTP requests to the service&rsquo;s endpoints. The messages will be sent as stringified JSON payloads.</p>
<p>To this end, the event queue service will expose the following endpoints:</p>
<ul>
<li><code>POST /enqueue</code>: Add a message to the queue.</li>
<li><code>GET /dequeue</code>: Remove and return a message from the queue.</li>
<li><code>GET /size</code>: Return the number of messages in the queue.</li>
<li><code>GET /capacity</code>: Return the total capacity of the queue.</li>
<li><code>GET /isEmpty</code>: Return true if the queue is empty.</li>
<li><code>GET /isFull</code>: Return true if the queue is full.</li>
</ul>
<p>I&rsquo;ll use the <code>net/http</code> package in Go to implement the HTTP server. Here&rsquo;s what the main function looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fe8019">func</span> <span style="color:#fabd2f">main</span>() {
</span></span><span style="display:flex;"><span>	size <span style="color:#fe8019">:=</span> os.<span style="color:#fabd2f">Getenv</span>(<span style="color:#b8bb26">&#34;RING_BUFFER_SIZE&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">if</span> size <span style="color:#fe8019">==</span> <span style="color:#b8bb26">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>		size = <span style="color:#b8bb26">&#34;1024&#34;</span>
</span></span><span style="display:flex;"><span>		log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;RING_BUFFER_SIZE environment variable not set, defaulting to %s&#34;</span>, size)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log.<span style="color:#fabd2f">Println</span>(<span style="color:#b8bb26">&#34;Making a new ring buffer with size:&#34;</span>, size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	size_int, err <span style="color:#fe8019">:=</span> strconv.<span style="color:#fabd2f">Atoi</span>(size)
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">if</span> err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>		log.<span style="color:#fabd2f">Fatalf</span>(<span style="color:#b8bb26">&#34;failed to convert RING_BUFFER_SIZE to int: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rb <span style="color:#fe8019">:=</span> <span style="color:#fabd2f">NewRingBuffer</span>(size_int)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	http.<span style="color:#fabd2f">HandleFunc</span>(<span style="color:#b8bb26">&#34;/enqueue&#34;</span>, <span style="color:#fabd2f">enqueueHandler</span>(rb))
</span></span><span style="display:flex;"><span>	http.<span style="color:#fabd2f">HandleFunc</span>(<span style="color:#b8bb26">&#34;/dequeue&#34;</span>, <span style="color:#fabd2f">dequeueHandler</span>(rb))
</span></span><span style="display:flex;"><span>	http.<span style="color:#fabd2f">HandleFunc</span>(<span style="color:#b8bb26">&#34;/size&#34;</span>, <span style="color:#fabd2f">handleSize</span>(rb))
</span></span><span style="display:flex;"><span>	http.<span style="color:#fabd2f">HandleFunc</span>(<span style="color:#b8bb26">&#34;/capacity&#34;</span>, <span style="color:#fabd2f">handleCapacity</span>(rb))
</span></span><span style="display:flex;"><span>	http.<span style="color:#fabd2f">HandleFunc</span>(<span style="color:#b8bb26">&#34;/isEmpty&#34;</span>, <span style="color:#fabd2f">handleIsEmpty</span>(rb))
</span></span><span style="display:flex;"><span>	http.<span style="color:#fabd2f">HandleFunc</span>(<span style="color:#b8bb26">&#34;/isFull&#34;</span>, <span style="color:#fabd2f">handleIsFull</span>(rb))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	PORT <span style="color:#fe8019">:=</span> <span style="color:#b8bb26">&#34;8080&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;Server listening on port %s\n&#34;</span>, PORT)
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">if</span> err <span style="color:#fe8019">:=</span> http.<span style="color:#fabd2f">ListenAndServe</span>(<span style="color:#b8bb26">&#34;:&#34;</span><span style="color:#fe8019">+</span>PORT, <span style="color:#fe8019">nil</span>); err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>		fmt.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;Server failed to start: %v\n&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>main</code> function reads the <code>RING_BUFFER_SIZE</code> environment variable to determine the size of the ring buffer. It then creates a new ring buffer with that size and sets up the HTTP server to handle requests to the various endpoints.</p>
<p>The <code>enqueueHandler</code>, <code>dequeueHandler</code>, <code>handleSize</code>, <code>handleCapacity</code>, <code>handleIsEmpty</code>, and <code>handleIsFull</code> functions are the handlers for the different endpoints.</p>
<h3 id="handling-requests">Handling Requests</h3>
<p>The <code>enqueueHandler</code> function handles requests to the <code>/enqueue</code> endpoint. It takes a payload that looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#fb4934">&#34;event&#34;</span>: <span style="color:#b8bb26">&#34;{\n  \&#34;randomNumber\&#34;: 7423872\n}&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>event</code> field contains the message to be added to the queue. The handler takes this message exactly as it is and adds it to the queue.</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fe8019">type</span> EnqueueRequest <span style="color:#fe8019">struct</span> {
</span></span><span style="display:flex;"><span>	Event <span style="color:#fabd2f">string</span> <span style="color:#b8bb26">`json:&#34;event&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fe8019">type</span> EnqueueResponse <span style="color:#fe8019">struct</span> {
</span></span><span style="display:flex;"><span>	Message <span style="color:#fabd2f">string</span> <span style="color:#b8bb26">`json:&#34;message&#34;`</span>
</span></span><span style="display:flex;"><span>	Event   <span style="color:#fabd2f">string</span> <span style="color:#b8bb26">`json:&#34;event&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> <span style="color:#fabd2f">enqueueHandler</span>(rb <span style="color:#fe8019">*</span>RingBuffer) http.HandlerFunc {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> <span style="color:#fe8019">func</span>(w http.ResponseWriter, r <span style="color:#fe8019">*</span>http.Request) {
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> r.Method <span style="color:#fe8019">!=</span> http.MethodPost {
</span></span><span style="display:flex;"><span>			http.<span style="color:#fabd2f">Error</span>(w, <span style="color:#b8bb26">&#34;Method not allowed&#34;</span>, http.StatusMethodNotAllowed)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;unexpected method %s on endpoint %s&#34;</span>, r.Method, r.URL.Path)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">var</span> req EnqueueRequest
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> err <span style="color:#fe8019">:=</span> json.<span style="color:#fabd2f">NewDecoder</span>(r.Body).<span style="color:#fabd2f">Decode</span>(<span style="color:#fe8019">&amp;</span>req); err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>			http.<span style="color:#fabd2f">Error</span>(w, err.<span style="color:#fabd2f">Error</span>(), http.StatusBadRequest)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;failed to decode request body: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> err <span style="color:#fe8019">:=</span> rb.<span style="color:#fabd2f">Enqueue</span>(req.Event); err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>			http.<span style="color:#fabd2f">Error</span>(w, err.<span style="color:#fabd2f">Error</span>(), http.StatusInternalServerError)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;failed to enqueue item: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		response <span style="color:#fe8019">:=</span> EnqueueResponse{
</span></span><span style="display:flex;"><span>			Message: <span style="color:#b8bb26">&#34;Successfully enqueued event&#34;</span>,
</span></span><span style="display:flex;"><span>			Event:   req.Event,
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		w.<span style="color:#fabd2f">Header</span>().<span style="color:#fabd2f">Set</span>(<span style="color:#b8bb26">&#34;Content-Type&#34;</span>, <span style="color:#b8bb26">&#34;application/json&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> err <span style="color:#fe8019">:=</span> json.<span style="color:#fabd2f">NewEncoder</span>(w).<span style="color:#fabd2f">Encode</span>(response); err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>			w.<span style="color:#fabd2f">WriteHeader</span>(http.StatusInternalServerError)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;failed to encode response: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Next, the <code>dequeueHandler</code> function handles requests to the <code>/dequeue</code> endpoint. It removes and returns the message at the head of the queue.</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fe8019">type</span> DequeueResponse <span style="color:#fe8019">struct</span> {
</span></span><span style="display:flex;"><span>	Message <span style="color:#fabd2f">string</span> <span style="color:#b8bb26">`json:&#34;message&#34;`</span>
</span></span><span style="display:flex;"><span>	Event   <span style="color:#fabd2f">string</span> <span style="color:#b8bb26">`json:&#34;event&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> <span style="color:#fabd2f">dequeueHandler</span>(rb <span style="color:#fe8019">*</span>RingBuffer) http.HandlerFunc {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> <span style="color:#fe8019">func</span>(w http.ResponseWriter, r <span style="color:#fe8019">*</span>http.Request) {
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> r.Method <span style="color:#fe8019">!=</span> http.MethodGet {
</span></span><span style="display:flex;"><span>			http.<span style="color:#fabd2f">Error</span>(w, <span style="color:#b8bb26">&#34;Method not allowed&#34;</span>, http.StatusMethodNotAllowed)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;unexpected method %s on endpoint %s&#34;</span>, r.Method, r.URL.Path)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		item, err <span style="color:#fe8019">:=</span> rb.<span style="color:#fabd2f">Dequeue</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>			http.<span style="color:#fabd2f">Error</span>(w, err.<span style="color:#fabd2f">Error</span>(), http.StatusInternalServerError)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;failed to dequeue item: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		response <span style="color:#fe8019">:=</span> DequeueResponse{
</span></span><span style="display:flex;"><span>			Message: <span style="color:#b8bb26">&#34;Successfully dequeued event&#34;</span>,
</span></span><span style="display:flex;"><span>			Event:   item.(<span style="color:#fabd2f">string</span>),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		w.<span style="color:#fabd2f">Header</span>().<span style="color:#fabd2f">Set</span>(<span style="color:#b8bb26">&#34;Content-Type&#34;</span>, <span style="color:#b8bb26">&#34;application/json&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> err <span style="color:#fe8019">:=</span> json.<span style="color:#fabd2f">NewEncoder</span>(w).<span style="color:#fabd2f">Encode</span>(response); err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>			w.<span style="color:#fabd2f">WriteHeader</span>(http.StatusInternalServerError)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;failed to encode response: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>handleSize</code>, <code>handleCapacity</code>, <code>handleIsEmpty</code>, and <code>handleIsFull</code> functions handle requests to the <code>/size</code>, <code>/capacity</code>, <code>/is_empty</code>, and <code>/is_full</code> endpoints, respectively. These are pretty self-explanatory:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#fe8019">type</span> SizeResponse <span style="color:#fe8019">struct</span> {
</span></span><span style="display:flex;"><span>	Size <span style="color:#fabd2f">int</span> <span style="color:#b8bb26">`json:&#34;size&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> <span style="color:#fabd2f">handleSize</span>(rb <span style="color:#fe8019">*</span>RingBuffer) http.HandlerFunc {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> <span style="color:#fe8019">func</span>(w http.ResponseWriter, r <span style="color:#fe8019">*</span>http.Request) {
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> r.Method <span style="color:#fe8019">!=</span> http.MethodGet {
</span></span><span style="display:flex;"><span>			http.<span style="color:#fabd2f">Error</span>(w, <span style="color:#b8bb26">&#34;Method not allowed&#34;</span>, http.StatusMethodNotAllowed)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;unexpected method %s on endpoint %s&#34;</span>, r.Method, r.URL.Path)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		response <span style="color:#fe8019">:=</span> SizeResponse{
</span></span><span style="display:flex;"><span>			Size: rb.<span style="color:#fabd2f">Size</span>(),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> err <span style="color:#fe8019">:=</span> json.<span style="color:#fabd2f">NewEncoder</span>(w).<span style="color:#fabd2f">Encode</span>(response); err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>			w.<span style="color:#fabd2f">WriteHeader</span>(http.StatusInternalServerError)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;failed to encode response: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">type</span> CapacityResponse <span style="color:#fe8019">struct</span> {
</span></span><span style="display:flex;"><span>	Capacity <span style="color:#fabd2f">int</span> <span style="color:#b8bb26">`json:&#34;capacity&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> <span style="color:#fabd2f">handleCapacity</span>(rb <span style="color:#fe8019">*</span>RingBuffer) http.HandlerFunc {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> <span style="color:#fe8019">func</span>(w http.ResponseWriter, r <span style="color:#fe8019">*</span>http.Request) {
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> r.Method <span style="color:#fe8019">!=</span> http.MethodGet {
</span></span><span style="display:flex;"><span>			http.<span style="color:#fabd2f">Error</span>(w, <span style="color:#b8bb26">&#34;Method not allowed&#34;</span>, http.StatusMethodNotAllowed)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;unexpected method %s on endpoint %s&#34;</span>, r.Method, r.URL.Path)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		response <span style="color:#fe8019">:=</span> CapacityResponse{
</span></span><span style="display:flex;"><span>			Capacity: rb.<span style="color:#fabd2f">Capacity</span>(),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> err <span style="color:#fe8019">:=</span> json.<span style="color:#fabd2f">NewEncoder</span>(w).<span style="color:#fabd2f">Encode</span>(response); err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>			w.<span style="color:#fabd2f">WriteHeader</span>(http.StatusInternalServerError)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;failed to encode response: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">type</span> IsEmptyResponse <span style="color:#fe8019">struct</span> {
</span></span><span style="display:flex;"><span>	IsEmpty <span style="color:#fabd2f">bool</span> <span style="color:#b8bb26">`json:&#34;isEmpty&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> <span style="color:#fabd2f">handleIsEmpty</span>(rb <span style="color:#fe8019">*</span>RingBuffer) http.HandlerFunc {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> <span style="color:#fe8019">func</span>(w http.ResponseWriter, r <span style="color:#fe8019">*</span>http.Request) {
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> r.Method <span style="color:#fe8019">!=</span> http.MethodGet {
</span></span><span style="display:flex;"><span>			http.<span style="color:#fabd2f">Error</span>(w, <span style="color:#b8bb26">&#34;Method not allowed&#34;</span>, http.StatusMethodNotAllowed)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;unexpected method %s on endpoint %s&#34;</span>, r.Method, r.URL.Path)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		response <span style="color:#fe8019">:=</span> IsEmptyResponse{
</span></span><span style="display:flex;"><span>			IsEmpty: rb.<span style="color:#fabd2f">IsEmpty</span>(),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> err <span style="color:#fe8019">:=</span> json.<span style="color:#fabd2f">NewEncoder</span>(w).<span style="color:#fabd2f">Encode</span>(response); err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>			w.<span style="color:#fabd2f">WriteHeader</span>(http.StatusInternalServerError)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;failed to encode response: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">type</span> IsFullResponse <span style="color:#fe8019">struct</span> {
</span></span><span style="display:flex;"><span>	IsFull <span style="color:#fabd2f">bool</span> <span style="color:#b8bb26">`json:&#34;isFull&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">func</span> <span style="color:#fabd2f">handleIsFull</span>(rb <span style="color:#fe8019">*</span>RingBuffer) http.HandlerFunc {
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">return</span> <span style="color:#fe8019">func</span>(w http.ResponseWriter, r <span style="color:#fe8019">*</span>http.Request) {
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> r.Method <span style="color:#fe8019">!=</span> http.MethodGet {
</span></span><span style="display:flex;"><span>			http.<span style="color:#fabd2f">Error</span>(w, <span style="color:#b8bb26">&#34;Method not allowed&#34;</span>, http.StatusMethodNotAllowed)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;unexpected method %s on endpoint %s&#34;</span>, r.Method, r.URL.Path)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		response <span style="color:#fe8019">:=</span> IsFullResponse{
</span></span><span style="display:flex;"><span>			IsFull: rb.<span style="color:#fabd2f">IsFull</span>(),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#fe8019">if</span> err <span style="color:#fe8019">:=</span> json.<span style="color:#fabd2f">NewEncoder</span>(w).<span style="color:#fabd2f">Encode</span>(response); err <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nil</span> {
</span></span><span style="display:flex;"><span>			w.<span style="color:#fabd2f">WriteHeader</span>(http.StatusInternalServerError)
</span></span><span style="display:flex;"><span>			log.<span style="color:#fabd2f">Printf</span>(<span style="color:#b8bb26">&#34;failed to encode response: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			<span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="dockerizing-the-event-queue-service">Dockerizing the Event Queue Service</h2>
<p>To make it easier to deploy the event queue service, I&rsquo;ll create a Docker image for it. The Dockerfile will look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="display:flex;"><span><span style="color:#fe8019">FROM</span><span style="color:#b8bb26"> golang:1.22</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">WORKDIR</span><span style="color:#b8bb26"> /app</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">RUN</span> apt-get update <span style="color:#fe8019">&amp;&amp;</span> apt-get install -y git
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">RUN</span> git clone https://github.com/malekoa/event-queue-service .
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">RUN</span> go mod download -x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">RUN</span> go build -o main .
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">CMD</span> [<span style="color:#b8bb26">&#34;./main&#34;</span>]
</span></span></code></pre></div><p>This Dockerfile uses the official Golang image as the base image. It installs Git, clones the repository, downloads the dependencies, builds the binary, and runs the binary when the container starts.</p>
<p>To build and run the Docker image, use the following commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker build -t event-queue-service .
</span></span><span style="display:flex;"><span>docker run -p 8080:8080 event-queue-service
</span></span></code></pre></div><h2 id="building-the-producer-and-consumer-services">Building the Producer and Consumer Services</h2>
<p>Now that we have the event queue service set up, we can build the two services that we want to communicate with each other using the event queue.</p>
<p>To keep things simple, both the producer and consumer services will just be infinite loops that send and receive messages from the event queue service. The producer will send a message every second, and the consumer will poll for messages every 500 milliseconds.</p>
<h3 id="producer-service">Producer Service</h3>
<p>The producer service needs to send messages that look like this, where the value of <code>event</code> is a stringified JSON payload:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#fb4934">&#34;event&#34;</span>: <span style="color:#b8bb26">&#34;{\n  \&#34;randomNumber\&#34;: 7423872\n}&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here&rsquo;s the code for the producer service, written in python using the <code>requests</code> library:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fe8019">import</span> json
</span></span><span style="display:flex;"><span><span style="color:#fe8019">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#fe8019">import</span> datetime
</span></span><span style="display:flex;"><span><span style="color:#fe8019">import</span> random
</span></span><span style="display:flex;"><span><span style="color:#fe8019">import</span> requests
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">def</span> <span style="color:#fabd2f">generate_event</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#b8bb26">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#b8bb26">    Generate a random event.
</span></span></span><span style="display:flex;"><span><span style="color:#b8bb26">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    event_name <span style="color:#fe8019">=</span> <span style="color:#b8bb26">&#34;EVENT_&#34;</span> <span style="color:#fe8019">+</span> <span style="color:#fabd2f">str</span>(random<span style="color:#fe8019">.</span>randint(<span style="color:#d3869b">0</span>, <span style="color:#d3869b">100</span>))
</span></span><span style="display:flex;"><span>    event_value <span style="color:#fe8019">=</span> random<span style="color:#fe8019">.</span>randint(<span style="color:#d3869b">0</span>, <span style="color:#d3869b">100</span>)
</span></span><span style="display:flex;"><span>    event_data <span style="color:#fe8019">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#b8bb26">&#34;event_name&#34;</span>: event_name,
</span></span><span style="display:flex;"><span>        <span style="color:#b8bb26">&#34;event_value&#34;</span>: event_value,
</span></span><span style="display:flex;"><span>        <span style="color:#b8bb26">&#34;event_time&#34;</span>: <span style="color:#fabd2f">str</span>(datetime<span style="color:#fe8019">.</span>datetime<span style="color:#fe8019">.</span>now()<span style="color:#fe8019">.</span>isoformat()),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#b8bb26">&#34;event&#34;</span>: json<span style="color:#fe8019">.</span>dumps(event_data),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">if</span> __name__ <span style="color:#fe8019">==</span> <span style="color:#b8bb26">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    EVENT_QUEUE_URL <span style="color:#fe8019">=</span> <span style="color:#b8bb26">&#34;http://localhost:8080/enqueue&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">while</span> <span style="color:#fe8019">True</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#fe8019">try</span>:
</span></span><span style="display:flex;"><span>            event <span style="color:#fe8019">=</span> generate_event()
</span></span><span style="display:flex;"><span>            response <span style="color:#fe8019">=</span> requests<span style="color:#fe8019">.</span>post(EVENT_QUEUE_URL, json<span style="color:#fe8019">=</span>event, timeout<span style="color:#fe8019">=</span><span style="color:#d3869b">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#fabd2f">print</span>(response<span style="color:#fe8019">.</span>text)
</span></span><span style="display:flex;"><span>        <span style="color:#fe8019">except</span> <span style="color:#fb4934">Exception</span> <span style="color:#fe8019">as</span> e:
</span></span><span style="display:flex;"><span>            <span style="color:#fabd2f">print</span>(<span style="color:#b8bb26">f</span><span style="color:#b8bb26">&#34;Error: </span><span style="color:#b8bb26">{</span>e<span style="color:#b8bb26">}</span><span style="color:#b8bb26">&#34;</span>)
</span></span><span style="display:flex;"><span>        time<span style="color:#fe8019">.</span>sleep(<span style="color:#d3869b">1</span>)
</span></span></code></pre></div><h3 id="consumer-service">Consumer Service</h3>
<p>The consumer service needs to poll the event queue service for messages and process them. Also, if the queue is empty, then the consumer should handle that case gracefully.</p>
<p>Here&rsquo;s the code for the consumer service:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fe8019">import</span> json
</span></span><span style="display:flex;"><span><span style="color:#fe8019">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#fe8019">import</span> requests
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">if</span> __name__ <span style="color:#fe8019">==</span> <span style="color:#b8bb26">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    EVENT_QUEUE_URL <span style="color:#fe8019">=</span> <span style="color:#b8bb26">&#34;http://localhost:8080/&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">while</span> <span style="color:#fe8019">True</span>:
</span></span><span style="display:flex;"><span>        is_empty <span style="color:#fe8019">=</span> json<span style="color:#fe8019">.</span>loads(requests<span style="color:#fe8019">.</span>get(EVENT_QUEUE_URL <span style="color:#fe8019">+</span> <span style="color:#b8bb26">&#34;isEmpty&#34;</span>, timeout<span style="color:#fe8019">=</span><span style="color:#d3869b">1</span>)<span style="color:#fe8019">.</span>text)
</span></span><span style="display:flex;"><span>        <span style="color:#fe8019">if</span> <span style="color:#fe8019">not</span> is_empty<span style="color:#fe8019">.</span>get(<span style="color:#b8bb26">&#34;isEmpty&#34;</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#fe8019">try</span>:
</span></span><span style="display:flex;"><span>                event <span style="color:#fe8019">=</span> json<span style="color:#fe8019">.</span>loads(
</span></span><span style="display:flex;"><span>                    requests<span style="color:#fe8019">.</span>get(EVENT_QUEUE_URL <span style="color:#fe8019">+</span> <span style="color:#b8bb26">&#34;dequeue&#34;</span>, timeout<span style="color:#fe8019">=</span><span style="color:#d3869b">1</span>)<span style="color:#fe8019">.</span>text
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>                <span style="color:#fabd2f">print</span>(<span style="color:#b8bb26">f</span><span style="color:#b8bb26">&#34;Consumed event: </span><span style="color:#b8bb26">{</span>event<span style="color:#b8bb26">}</span><span style="color:#b8bb26">&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#fe8019">except</span> <span style="color:#fb4934">Exception</span> <span style="color:#fe8019">as</span> e:
</span></span><span style="display:flex;"><span>                <span style="color:#fabd2f">print</span>(<span style="color:#b8bb26">f</span><span style="color:#b8bb26">&#34;Error: </span><span style="color:#b8bb26">{</span>e<span style="color:#b8bb26">}</span><span style="color:#b8bb26">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fe8019">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#fabd2f">print</span>(<span style="color:#b8bb26">&#34;Queue is empty.&#34;</span>)
</span></span><span style="display:flex;"><span>        time<span style="color:#fe8019">.</span>sleep(<span style="color:#d3869b">0.5</span>)
</span></span></code></pre></div><h2 id="running-the-services">Running the Services</h2>
<p>If you&rsquo;ve followed along so far, you should have the event queue service running in a Docker container. You can now run the producer and consumer services in separate terminals to see them communicate with each other through the event queue. The producer will send a message every second, and the consumer will poll for messages every 500 milliseconds. The output should look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#928374;font-style:italic"># Terminal 1</span>
</span></span><span style="display:flex;"><span>$ python producer.py
</span></span><span style="display:flex;"><span><span style="color:#fe8019">{</span><span style="color:#b8bb26">&#34;message&#34;</span>:<span style="color:#b8bb26">&#34;Successfully enqueued event&#34;</span>,<span style="color:#b8bb26">&#34;event&#34;</span>:<span style="color:#b8bb26">&#34;{\&#34;event_name\&#34;: \&#34;EVENT_42\&#34;, \&#34;event_value\&#34;: 42, \&#34;event_time\&#34;: \&#34;2024-06-15T19:26:35.000000\&#34;}&#34;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">{</span><span style="color:#b8bb26">&#34;message&#34;</span>:<span style="color:#b8bb26">&#34;Successfully enqueued event&#34;</span>,<span style="color:#b8bb26">&#34;event&#34;</span>:<span style="color:#b8bb26">&#34;{\&#34;event_name\&#34;: \&#34;EVENT_12\&#34;, \&#34;event_value\&#34;: 12, \&#34;event_time\&#34;: \&#34;2024-06-15T19:26:36.000000\&#34;}&#34;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">{</span><span style="color:#b8bb26">&#34;message&#34;</span>:<span style="color:#b8bb26">&#34;Successfully enqueued event&#34;</span>,<span style="color:#b8bb26">&#34;event&#34;</span>:<span style="color:#b8bb26">&#34;{\&#34;event_name\&#34;: \&#34;EVENT_99\&#34;, \&#34;event_value\&#34;: 99, \&#34;event_time\&#34;: \&#34;2024-06-15T19:26:37.000000\&#34;}&#34;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">{</span><span style="color:#b8bb26">&#34;message&#34;</span>:<span style="color:#b8bb26">&#34;Successfully enqueued event&#34;</span>,<span style="color:#b8bb26">&#34;event&#34;</span>:<span style="color:#b8bb26">&#34;{\&#34;event_name\&#34;: \&#34;EVENT_23\&#34;, \&#34;event_value\&#34;: 23, \&#34;event_time\&#34;: \&#34;2024-06-15T19:26:38.000000\&#34;}&#34;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">{</span><span style="color:#b8bb26">&#34;message&#34;</span>:<span style="color:#b8bb26">&#34;Successfully enqueued event&#34;</span>,<span style="color:#b8bb26">&#34;event&#34;</span>:<span style="color:#b8bb26">&#34;{\&#34;event_name\&#34;: \&#34;EVENT_77\&#34;, \&#34;event_value\&#34;: 77, \&#34;event_time\&#34;: \&#34;2024-06-15T19:26:39.000000\&#34;}&#34;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#928374;font-style:italic"># Terminal 2</span>
</span></span><span style="display:flex;"><span>$ python consumer.py
</span></span><span style="display:flex;"><span>Consumed event: <span style="color:#fe8019">{</span><span style="color:#b8bb26">&#39;event_name&#39;</span>: <span style="color:#b8bb26">&#39;EVENT_42&#39;</span>, <span style="color:#b8bb26">&#39;event_value&#39;</span>: 42, <span style="color:#b8bb26">&#39;event_time&#39;</span>: <span style="color:#b8bb26">&#39;2024-06-15T19:26:35.000000&#39;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span>Queue is empty.
</span></span><span style="display:flex;"><span>Consumed event: <span style="color:#fe8019">{</span><span style="color:#b8bb26">&#39;event_name&#39;</span>: <span style="color:#b8bb26">&#39;EVENT_12&#39;</span>, <span style="color:#b8bb26">&#39;event_value&#39;</span>: 12, <span style="color:#b8bb26">&#39;event_time&#39;</span>: <span style="color:#b8bb26">&#39;2024-06-15T19:26:36.000000&#39;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span>Queue is empty.
</span></span><span style="display:flex;"><span>Consumed event: <span style="color:#fe8019">{</span><span style="color:#b8bb26">&#39;event_name&#39;</span>: <span style="color:#b8bb26">&#39;EVENT_99&#39;</span>, <span style="color:#b8bb26">&#39;event_value&#39;</span>: 99, <span style="color:#b8bb26">&#39;event_time&#39;</span>: <span style="color:#b8bb26">&#39;2024-06-15T19:26:37.000000&#39;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span>Queue is empty.
</span></span><span style="display:flex;"><span>Consumed event: <span style="color:#fe8019">{</span><span style="color:#b8bb26">&#39;event_name&#39;</span>: <span style="color:#b8bb26">&#39;EVENT_23&#39;</span>, <span style="color:#b8bb26">&#39;event_value&#39;</span>: 23, <span style="color:#b8bb26">&#39;event_time&#39;</span>: <span style="color:#b8bb26">&#39;2024-06-15T19:26:38.000000&#39;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span>Queue is empty.
</span></span><span style="display:flex;"><span>Consumed event: <span style="color:#fe8019">{</span><span style="color:#b8bb26">&#39;event_name&#39;</span>: <span style="color:#b8bb26">&#39;EVENT_77&#39;</span>, <span style="color:#b8bb26">&#39;event_value&#39;</span>: 77, <span style="color:#b8bb26">&#39;event_time&#39;</span>: <span style="color:#b8bb26">&#39;2024-06-15T19:26:39.000000&#39;</span><span style="color:#fe8019">}</span>
</span></span><span style="display:flex;"><span>Queue is empty.
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>While this is a very simple example, it demonstrates the power of using an event queue to decouple components in a distributed system. There are many ways to extend this example from adding multiple queues to implementing retries. Another huge improvement that wouldn&rsquo;t be too difficult to implement would be dynamically resizing the ring buffer when it reaches its capacity. I&rsquo;ll probably get around to that at some point.</p>

</div>


    </main>

    
      
    
  </body>
</html>
